package Ritmo 2021;

/* autogenerated by Processing revision 1283 on 2022-08-07 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import processing.sound.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class ritmo2021_Android extends PApplet {

//Ritmo 2021 Android v1.0 English credits

/*
Directing:
 Luis Fernando Medina Cardona (luscus) - Associate Professor, Universidad Nacional de Colombia. Head researcher.
 Julian David Sandoval Ospina (Bonnie) - Research Assistant
 
 Coding: Bonnie, Luscus
 
 Music composing: Bonnie
 */

/*
Ritmo 2021: production of an experimental short film using computer programming - Project funded by the research-creation projects 2020 calling - Faculty of Arts, Universidad Nacional de Colombia (Bogotá campus)
 Research group: </espam> - Open Media Production Space. Creative Research Group. Faculty of Arts, Universidad Nacional de Colombia (Bogotá Campus)
 */

//Headphones or good audio system is adviced. Depending on the sound card and the Sound Processing Library. the quality of sound might be affected.
//Download other artifacts at: linktr.ee/ritmo2021
//Copyleft 2021-2022





int[] colorArray ={
  color(241, 228, 126), // 0 - light yellow
  color(240, 81, 36), // 2 - orange
  color(55, 139, 189), // 4 - blue
  color(185, 44, 58), // 3 - wine
  color(57, 188, 168), // 5 - green
  color(245, 166, 31)// 1 - ocher
};

//----- SOUND

SinOsc osc1;
SinOsc osc2;
SinOsc osc3;
SinOsc osc4;

PinkNoise noise1;
Env env;


//----- IMAGE

int colorShift;
int colorShift2;
int colorShift3;
int colorShift4;
int colorShift5;



int MenuState=0; //Control the windows of the menu 
float rotationSpeed = 0; //rotation speed

float dpi = displayDensity;   // a factor used to scale the graphical elements

Button playbutton;  //Play Button
Movie movie;

 public void setup() {
  orientation(LANDSCAPE);
  /* size commented out by preprocessor */;
  //size(800, 500, P3D);
  frameRate(60);

  playbutton = new Button(width/2, height/2, 400, 150, "Play", 0, 200, 200);

  osc1 = new SinOsc(this);
  osc2 = new SinOsc(this);
  osc3 = new SinOsc(this);
  osc4 = new SinOsc(this);
  noise1 = new PinkNoise(this);
  env = new Env(this);

  movie = new Movie(osc1, osc2, osc3, osc4, noise1, env);
}

//----- VISUAL


 public void draw() {

  switch (MenuState) {
  case 0:
    menu();
    break;

  case 1:
    movie.display();
    break;

  default:
    println("Error: Unknown state error ");
    MenuState = 0;
    break;
  }
} // Draw end



 public void menu() {

  background(44, 43, 86);

  playbutton.render();
  playbutton.update();

  translate(width/2, height/2);
  rotationSpeed = rotationSpeed+0.0005f ;
  
  noFill();
  
  
  //----- VISUAL


  rotateX(120+rotationSpeed);
  rotateY(120);
  rotateZ(120);
  stroke (255, 255, 255);
  box(height/2);


  rotateX(240-rotationSpeed);
  rotateY(300-rotationSpeed);
  rotateZ(120-rotationSpeed);
  stroke (255, 255, 255);
  box(height/2);

  if (playbutton.isClicked()) {
    delay(100);
    MenuState = 1;
  }
}
class Button{
 
  PVector Pos = new PVector(0,0);
  float Width = 0; 
  float Height = 0;
  int Colour; 
  String Text; 
  Boolean Pressed = false;
  Boolean Clicked = false; 
  
  //Constructor to create a button 
  Button(int x, int y, int w, int h, String t, int r, int g, int b){
   Pos.x = x;
   Pos.y = y;
   Width = w;
   Height = h;
   Colour = color(r,g,b);
   Text = t; 
  }
  
   public void update(){
    if(mousePressed == true && Pressed == false){
      Pressed = true; 
      if (mouseX >= Pos.x - Width/2 && mouseX <= Pos.x + Width/2 && mouseY >= Pos.y - Height/2 && mouseY <= Pos.y + Height/2){
        Clicked = true; 
      }
    } else{
        Clicked = false;
        Pressed = false;
      }
  } // end update
  
   public void render(){
    noStroke();
    fill(Colour);
    rectMode(CENTER);
    rect(Pos.x, Pos.y, Width * dpi, Height * dpi);
    
    fill(0);
    textFont(createFont("UbuntuMono-R.ttf",height*0.04f));
    textAlign (CENTER, CENTER);
    textSize(56 * dpi);
    text(Text, Pos.x , Pos.y );
  } //end render
  
   public boolean isClicked(){  //Use this in a if statement to check of the button has been clicked
    return Clicked;
  }
  
}

class Movie {
  //Control variables
  int totalScenes=15; // total number of scenes. Increase if a new scene is added
  int sceneCount =-1; // Current scene
  int state=0; // Scene state (0 = building scene, 1 = Playing scene)

  //Scene variables
  Scene[] scenesVector = new Scene[totalScenes];//Each scene is an instance of the sceneAbstract superclass and is stored in a vector.
  int[] scenesDuration = {480, 1920, 960, 1920, /**/1785, 1020, 1020, 1020, /**/1020, 765, 1020, 1020, /**/1020, 1020, 1700};//Scene duration in frames.
  //480,1920,960,1920,/**/2040,960,1440,1530,/**/770,1550,1520,770,/**/960,3070,500

  Scene currentScene;//Object pointing to the currents scene

  Boolean Pressed = false;
  Boolean Clicked = false;

  //Touchscreen interaction are provided for debugging
   public void update() {
    if (mousePressed == true && Pressed == false) {
      Pressed = true;
      if ( mouseX > width/2) {         //An event on the right of the screen  -> next scene
        //println("Next Escene" + sceneCount);
        try {
          currentScene.finishScene();
          if (sceneCount != 14) {
            currentScene.finishScene();
          } else {
            MenuState = 0;
            sceneCount = 0;
          }
        }
        catch(Exception e) {
          MenuState = 0;
          println("Error Escena");
        }
      }

      if ( mouseX < width/2) {        //An event on the left of the screen-> previous scene
        if (sceneCount > 0) sceneCount=sceneCount-2;
        state=0;
      }
    } else {
      Clicked = false;
    }

    if (mousePressed != true) {
      Pressed = false;
    }
  }// end update

  //this function changes the color palette depending on the current frame
   public void colorClock() {

    if (frameCount%15==0) {
      colorShift = colorShift +1;
      if (colorShift==colorArray.length)
        colorShift=0;
    }

    if (frameCount%30==0) {
      colorShift2 = colorShift2 +1;
      if (colorShift2==colorArray.length)
        colorShift2=0;
    }

    if (frameCount%60==0) {
      colorShift3 = colorShift3 +1;
      if (colorShift3==colorArray.length)
        colorShift3=0;
    }

    if (frameCount%120==0) {
      colorShift4 = colorShift4 +1;
      if (colorShift4==colorArray.length)
        colorShift4=0;
    }

    if (frameCount%240==0) {
      colorShift5 = colorShift5 +1;
      if (colorShift5==colorArray.length)
        colorShift5=0;
    }
  }


  //selects a scene in sequence
   public void seqSelector() {
    if (state==0 && sceneCount < totalScenes - 1) {
      sceneCount=sceneCount+1;
      println("Escena " + sceneCount);
    }
  }

  //displays a scene stored in the vector
   public void displaySceneVector(int sceneIndex) {
    if (state==0) {
      scenesVector[sceneIndex].setDuration(scenesDuration[sceneIndex]);
      currentScene=scenesVector[sceneIndex];
      state=1;
    } else
    {
      if (!scenesVector[sceneIndex].isEndScene()) {
        scenesVector[sceneIndex].display();
      } else {
        state=0;
      }
    }
  }

  //Constructor to create the movie
  Movie(SinOsc osc1, SinOsc osc2, SinOsc osc3, SinOsc osc4, PinkNoise noise1, Env env) {

    //Every scene is created using a constructor whose only paremeter is the scene duration. All scenes are created with a zero frames duration
    // thereafter displaySceneVector modifies each scene duration folowwing the number of frames stored in the vector scenesDuration
    scenesVector[0]=new Scene00(0);
    scenesVector[1]=new Scene01(0);
    scenesVector[2]=new Scene02(0);
    scenesVector[3]=new Scene03(0);
    scenesVector[4]=new Scene04(0);
    scenesVector[5]=new Scene05(0);
    scenesVector[6]=new Scene06(0);
    scenesVector[7]=new Scene07(0);
    scenesVector[8]=new Scene08(0);
    scenesVector[9]=new Scene09(0);
    scenesVector[10]=new Scene10(0);
    scenesVector[11]=new Scene11(0);
    scenesVector[12]=new Scene12(0);
    scenesVector[13]=new Scene13(0);
    scenesVector[14]=new Scene14(0);

    //----- SOUND
    osc1 = osc1;
    osc2 = osc3;
    osc3 = osc3;
    osc4 = osc4;
    noise1 = noise1;
    env = env;
  }


   public void display() {
    colorClock ();
    seqSelector();
    displaySceneVector(sceneCount);
    //update();
  }
}
//initial credits scene
class Scene00 extends Scene {  // class begins
// visual attributes
PFont font1;
int delay;
String[] titles = {"ritmo 2021();","{ritmo 2021}","ritmo 2021[]", "</ritmo 2021>","ritmo@2021>"};
// sound attributes
float SinLFOin;
float SawLFOin;
int Alternator;
float Volume1;
float Volume2;

int[] midiSequence1 = {52,55,47,55,0,0,0,0,/**/52,57,55,59,54,59,55,52,/**/48,52,55,59,48,52,55,59,/**/55,57,55,59,54,59,55,52};// Lead Line
int[] midiSequence2 = {40,42,35,43,0,0,0,0,/**/52,52,52,52,52,52,52,52,/**/48,48,48,48,48,48,48,48,/**/48,48,48,48,48,48,48,48};// Bass line
int[] midiSequence3 = {40,42,35,43,0,0,0,0,/**/53,53,53,53,53,53,53,53,/**/47,47,47,47,47,47,47,47,/**/47,47,47,47,47,47,47,47};// Drone
int[] midiSequence4 = {0,0,0,0,74,81,0,0,/**/0,0,0,0,0,0,0,100,/**/0,0,0,0,0,79,0,79,/**/0,0,88,0,0,0,0,100};// Clic
int trigger = delay; 
int note = 0; 

//constructor
Scene00(int _sceneDuration){
  sceneDuration=_sceneDuration;
  font1 = createFont("UbuntuMono-R.ttf",height*0.04f);
  } //cosntructor ends


 public float midiToHz(int note) {
  return (pow(2, ((note-69)/12.0f))) * 440;
  }

 public void display () { // Display begins  
  delay = delay +1;
  int duration = 120; 
  fill(colorArray[colorShift4]);
   if (delay>=340){       
 //      duration = 5940;
 //     fill(colorArray[4]);
     }
  
  //----- SOUND
  

      
     noise1.play();
     noise1.amp(0.05f);//0.2
       
       //osc1.play(midiToHz(midiSequence1[note]), 0.4);
   
   if ((delay > trigger) && (note<midiSequence1.length)) { // trigger begins    
      osc1.play(midiToHz(midiSequence1[note]), 0.8f);//SawLFO*0.4
      env.play(osc1, 0.5f, 0.1f, 0.5f, 2.5f); //osc1, attackTime, sustainTime, sustainLevel, releaseTime // 0.01, 0.007, 0.7, 1.5
      osc2.play(midiToHz(midiSequence2[note]), 0.2f);//SawLFO*0.4
      env.play(osc2, 0.5f, 0.1f, 0.5f, 2.5f);
      osc3.play(midiToHz(midiSequence2[note]), 0.2f);//0.4
       // env.play(osc3, attackTime, sustainTime, sustainLevel, releaseTime*2);
       // osc4.play(210, 0);//0.4             
      trigger = delay + duration;
      // Sequencer
      note = note+1;
      if (note == 32) {
        note = 0;
        }
   } // trigger ends
    
  //----- VISUAL
  
  background(44,43,86);
  pushMatrix();
  translate(width/2,height/2);
  textAlign(CENTER);
  textFont(font1);
  //fill(colorArray[colorShift2]);
  //text("RITMO 2021",0,10);
  text(titles[4-PApplet.parseInt(sceneDuration/120)],0,10);
  popMatrix();
  
  frameCompleted();
  
  }// Display ends    


}//class ends
class Scene01 extends Scene{  // class begins

int delay;

//----- SOUND

float SinLFOin;
float SawLFOin;
int Alternator;
float Volume1;
float Volume2;

int[] midiSequence1 = {52,55,48,55,54,54,54,54,/**/52,57,55,59,54,59,55,52,/**/52,52,52,52,0,0,0,0,/**/52,52,52,52,54,54,54,54};// Lead Line 48,52,55,59,48,52,55,59,/**/55,57,55,59,54,59,55,52
int[] midiSequence2 = {40,42,35,43,52,52,52,52,/**/52,52,52,52,48,48,48,48,/**/48,48,48,48,48,48,0,0,/**/48,48,48,48,45,45,45,45};// Bass line
int[] midiSequence3 = {53,53,53,53,53,53,53,53,/**/53,53,53,53,53,53,53,53,/**/48,48,48,47,47,47,47,47,/**/47,47,47,47,47,47,47,47};// Drone
int[] midiSequence4 = {0,0,0,0,74,81,0,81,/**/0,0,0,0,0,0,0,100,/**/0,0,0,0,0,79,0,79,/**/0,0,88,0,0,0,0,100};// Clic




 public float midiToHz(int note) {
  return (pow(2, ((note-69)/12.0f))) * 440;
  }

int trigger = frameCount; 
int note = 0; 


//----- IMAGE

   Box02 b1; 
   PVector[] pos;
   int particleLenght = 4; // number of particles
   float spawnClock; // clock for particle creation
   float spawnTime=192; // time spam for particle creation

Scene01(int _sceneDuration){ //constructor begins 

    sceneDuration=_sceneDuration;
    b1 = new Box02(300,4500,300);
    pos = new PVector[particleLenght];
    for(int i = 0; i < pos.length; i = i+1){//for begin
       pos[i] = new PVector(random(-width/3,width/3), random(-height/3,height/3)); 
    }//for ends
} // constructor ends


//SPAWNPARTICLES create particles every 240 frames 
 public void spawnParticles () {  // function begins
          if (frameCount% 240==0) {
          spawnClock = spawnClock +1;
          if (spawnClock>= pos.length)
          spawnClock=pos.length;
          }      
  
}// function ends

 public void display() {  // function begins
  background(44,43,86);
  
   //----- SOUND
   
   int duration = 120;
  
      
       noise1.play();
       noise1.amp(0.05f);//0.2
       
       //osc1.play(midiToHz(midiSequence1[note]), 0.4);
      
            
  
    if ((frameCount > trigger) && (note<midiSequence1.length)) { // trigger begins

       
        osc1.play(midiToHz(midiSequence1[note]), 0.8f);//SawLFO*0.4
        env.play(osc1, 0.5f, 0.1f, 0.5f, 2); //osc1, attackTime, sustainTime, sustainLevel, releaseTime // 0.01, 0.007, 0.7, 1.5
        osc2.play(midiToHz(midiSequence2[note]), 0.2f);//SawLFO*0.4
        env.play(osc2, 0.5f, 0.1f, 0.5f, 2);
       // osc3.play(midiToHz(midiSequence2[note]), 0.1);//0.4
       // env.play(osc3, attackTime, sustainTime, sustainLevel, releaseTime*2);
       // osc4.play(210, 0);//0.4     
           
        trigger = frameCount + duration;

       // Sequencer
          note = note+1;
          if (note == 32) {
            note = 0;
          }
    } // trigger end
  
  //----- VISUAL
  
  translate(width/2,height/2);
  spawnParticles();
  for(int i = 0; i < spawnClock; i= i+1){ //for begin
    pushMatrix();
    b1.pos(pos[i].x,pos[i].y);
    b1.rot();
    b1.display();
    popMatrix();
   }//for end
  frameCompleted();


 }//function end
 
}//class end



class Box02 { //Class Box Begin
  float r; 
  float sizeX;
  float sizeY;
  float sizeZ;


  Box02(int tempSizeX, int tempSizeY, int tempSizeZ) { 
    
    sizeX = tempSizeX;
    sizeY = tempSizeY;
    sizeZ = tempSizeZ;
   
  }
  
  //POSITION locates the boxes
     public void pos (float tempX, float tempY) { 
     translate(tempX, tempY); 
  }
  
   //rotates the whole scene
   public void rot () {    
    rotateX(0); 
    rotateY(r); // rotion axis is Y
    rotateZ(0.787f);
    r = r+0.002f;
  }
  
  //DISPLAY 
   public void display () {
    box (sizeX,sizeY,sizeZ) ;
    fill(colorArray[colorShift4],150);
    stroke(44,43,86);
    noStroke();
  }    
}  //class Box ends
class Scene02 extends Scene{  // class begins
float rot;
int delay;

//----- SOUND

float SinLFOin;
float SawLFOin;
int Alternator;
float Volume1;
float Volume2;

int[] midiSequence1 = {52,52,52,52,52,52,52,52,/**/0,0,0,0,0,0,0,0,/**/54,59,57,60,54,54,54,54,/**/52,52,52,52,54,54,54,54};// Lead Line 48,52,55,59,48,52,55,59,/**/55,57,55,59,54,59,55,52
int[] midiSequence2 = {48,48,48,48,48,48,48,48,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,47,47,47,47,/**/48,48,48,48,0,0,0,0};// Bass line
int[] midiSequence3 = {48,48,48,48,48,48,48,48,/**/0,0,0,0,0,0,0,0,/**/47,47,47,47,47,47,47,47,/**/47,47,47,47,47,47,47,47};// Drone
int[] midiSequence4 = {0,0,0,0,74,81,0,81,/**/0,0,0,0,0,0,0,100,/**/0,0,0,0,0,79,0,79,/**/0,0,88,0,0,0,0,100};// Clic

//----- VISUAL

float  r; //radius
int total = 50; // number of points
float rotationSpeed; //rotation speed



 public float midiToHz(int note) {
  return (pow(2, ((note-69)/12.0f))) * 440;
  }

int trigger = delay; 
int note = 0; 

    
Scene02(int _sceneDuration){
  rectMode(CENTER);
  sceneDuration=_sceneDuration;
}

 public void display() { // function begins

delay = delay +1;

 //----- SOUND
   
   int duration = 120; 
  
   SawLFOin=SawLFOin+1;    
   if (delay%480==0) { // sawLFO function Begins (saw LFO)
    SawLFOin=-1*SawLFOin;
     }
     float SawLFO = map(SawLFOin, 0, 480, 0, 1);
     
 
      
       noise1.play();
       noise1.amp(0.05f);//0.2
       
       //osc1.play(midiToHz(midiSequence1[note]), 0.4);
      
            
  
    if ((delay > trigger) && (note<midiSequence1.length)) { // trigger begins

       
        osc1.play(midiToHz(midiSequence1[note]), 0.8f);//SawLFO*0.4
        env.play(osc1, 0.5f, 0.1f, 0.5f, 2); //osc1, attackTime, sustainTime, sustainLevel, releaseTime // 0.01, 0.007, 0.7, 1.5
        osc2.play(midiToHz(midiSequence2[note]), 0.2f*SawLFO);//SawLFO*0.4
        env.play(osc2, 0.5f, 0.1f, 0.5f, 2);
       //osc3.play(midiToHz(midiSequence2[note]), 0.1*SawLFO);//0.4
       // osc3.play(200, 0);//0.4
       // env.play(osc3, attackTime, sustainTime, sustainLevel, releaseTime*2);
       // osc4.play(210, 0);//0.4     
           
        trigger = delay + duration;

       // Sequencer
          note = note+1;
          if (note == 32) {
            note = 0;
          }
    } // trigger ends

//----- VISUAL
 
    if (delay>=120){    
   
       background(240,81,36);   
    
     } //if end
     
     if (delay>=240){    
   
       background(55,139,189);
      
     } //if end
     
      if (delay>=360){    
   
       background(44,43,86);
      
     } //if end
      
        
     if (delay>=480){//if begins 
      
       background(44,43,86);
       r = height/3;
       translate(width/2,height/2);
       rotateX(rotationSpeed*2);
       rotateY(120);
       rotateZ(rotationSpeed);
       rotationSpeed = rotationSpeed+0.001f;
   
        float offset = 0;
   
      for (int i = 0; i < total;i = i+1){ // for 1 begins
      float lon = map(i,0,total,-PI,PI); // longitude
      for (int j = 0; j < total;j = j+1)  { // for 2 begins
        
                
        float lat = map(j,0,total,-HALF_PI,HALF_PI); // latitude
        float x = r * sin (lon) * cos (lat);
        float y = r * sin (lon) * sin (lat);
        float z = r * cos (lon);
        
        stroke(colorArray[colorShift4]);
        strokeWeight(2);
        point(x,y,z);
        
           offset = offset + 0.01f;
  
   } // for 2 end
   } // for 1 end  
   } //if end
   
 
   frameCompleted();
 
 }//function ends
 
}//class ends
class Scene03 extends Scene { //class begins
int delay;

//----- SOUND

float SinLFOin;
float SawLFOin;
int Alternator;
float Volume1;
float Volume2;

int[] midiSequence1 = {0,47,0,47,0,47,0,47,/**/0,48,0,48,0,48,0,48,/**/0,50,0,50,0,50,0,50,/**/0,52,0,52,0,52,0,52};// Lead Line 48,52,55,59,48,52,55,59,/**/55,57,55,59,54,59,55,52
int[] midiSequence2 = {40,40,40,40,40,40,40,40,/**/40,40,40,40,40,40,40,40,/**/40,40,40,40,40,40,40,40,/**/40,40,40,40,40,40,40,40};// Bass line
int[] midiSequence3 = {52,52,52,52,55,55,55,55,/**/57,57,57,57,52,52,52,52,/**/52,52,52,52,57,57,57,57,/**/55,55,55,55,59,59,59,59};// Drone
int[] midiSequence4 = {0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0};// Clic




 public float midiToHz(int note) {
  return (pow(2, ((note-69)/12.0f))) * 440;
  }

int trigger = delay; 
int note = 0; 

//----- VISUAL

float  r; //radius
int total = 50; // number of points
float rotationSpeed; //rotation speed

float BNshift = 0;
float BNshift2 = 0;
  
Scene03(int _sceneDuration) { // constructor begins
  sceneDuration=_sceneDuration;
  ortho();
} //cosntructor ends

 public void display() { // Display begins

  background(44,43,86);
  
  //----- SOUND
   
   int duration = 30; 
        
       noise1.play();
       noise1.amp(0.05f);//0.2
       
       //osc1.play(midiToHz(midiSequence1[note]), 0.4);
                  
    if ((delay > trigger) && (note<midiSequence1.length)) { // trigger begins
      
        osc1.play(midiToHz(midiSequence1[note]), 0.8f);//SawLFO*0.4
       // env.play(osc1, 0.1, 0.1, 0.5,2); //osc1, attackTime, sustainTime, sustainLevel, releaseTime // 0.01, 0.007, 0.7, 1.5
        osc2.play(midiToHz(midiSequence2[note]), 0.2f);//SawLFO*0.4
        env.play(osc2, 0.5f, 0.1f, 0.5f, 2);
        osc3.play(midiToHz(midiSequence3[note]), 0.2f);//0.4
        env.play(osc3, 0.5f, 0.1f, 0.5f, 2);
       // osc4.play(210, 0.1*SawLFO);//0.4     
           
        trigger = delay + duration;

       // Sequencer
          note = note+1;
          if (note == 32) {
            note = 0;
          }
    } // trigger ends
  
  
  //VISUAL
  
  translate(width/2,height/2);
  rotateX(rotationSpeed*2);
  rotateY(120);
  rotateZ(rotationSpeed);
  rotationSpeed = rotationSpeed+0.002f;
  delay = delay +1;
  
  if (delay%120==0) {
    BNshift = BNshift +1;
    BNshift2 = BNshift2 +1;
    }  

      if (BNshift%2==0) { //if else begins
        background(241,228,126);
      } else {
        background(44,43,86);        
      } // if else end
      
     
      if (delay>=1) {
          r = height/3;
        }  
        
      if (delay>=120) {
          r = height/2;
        }  
        
      if (delay>=240) {
          r = 2*height/3;
        }
        
      if (delay>=600) {
          r = height/3;
        }
        
      if (delay>=720) {
          r = height/4;
        }
        
      if (delay>=840) {
          r = height/3;
        }  
        
      if (delay>=1080) {
          r = height/2;
        }
        
       if (delay>=1200) {
          r = height;
        }
        
       if (delay>=1440) {
          r = 2*height/3;
        } 
        
  

   
   float offset = 0;
   
      for (int i = 0; i < total;i = i+1){ // for 1 begin
      float lon = map(i,0,total,-PI,PI); // longitude
      for (int j = 0; j < total;j = j+1)  { // for 2 begin
        
                
        float lat = map(j,0,total,-HALF_PI,HALF_PI); // latitude
        float x = r * sin (lon) * cos (lat);
        float y = r * sin (lon) * sin (lat);
        float z = r * cos (lon);
        
        stroke(colorArray[colorShift3]);
        strokeWeight(3);
        point(x,y,z);
        
           offset = offset + 0.01f;
  
       } // for 2 end
     } // for 1 end  
  
   
     
    
   
     
  frameCompleted();
  
} // Display ends
} //class ends 
class Scene04 extends Scene { //class begin

//SHAPE VARIABLES
float  r = height/3; //radius
int total = 50; // number of points
float rotationSpeed; //rotation speed
int delay;

//----- SOUND

float SinLFOin;
float SawLFOin;
int Alternator;
float Volume1;
float Volume2;

int[] midiSequence1 = {47,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/52,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0};// Lead Line 48,52,55,59,48,52,55,59,/**/55,57,55,59,54,59,55,52
int[] midiSequence2 = {0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0};// Bass line
int[] midiSequence3 = {0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0};// Drone
int[] midiSequence4 = {0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0};// Clic

 public float midiToHz(int note) {
  return (pow(2, ((note-69)/12.0f))) * 440;
  }

int trigger = delay; 
int note = 0; 

//----- VISUAL



  
Scene04(int _sceneDuration) { // constructor begin
  sceneDuration=_sceneDuration;
  //ortho();
} //cosntructor end

 public void display() { // Display begin
  background(241,228,126);
  translate(width/2,height/2);
  rotationSpeed = rotationSpeed+0.0005f ;
  delay = delay +1;
  noFill();
    
  //----- SOUND
   
   int duration = 15;
   
   SinLFOin=(sin(delay*0.030f));
     float SinLFO = map(SinLFOin,-1,1, 1,0);
        
       noise1.play();
       noise1.amp(0.05f);//0.2
       
       //osc1.play(midiToHz(midiSequence1[note]), 0.4);
      
            
  
    if ((delay > trigger) && (note<midiSequence1.length)) { // trigger begin

       
        osc1.play(midiToHz(midiSequence1[note]+12), 0.4f);//0.2
        env.play(osc1, 0.5f, 0.1f, 0.1f,2); //
       // osc2.play(midiToHz(midiSequence2[note]), 0.1);//
       // env.play(osc2, 0.5, 0.1, 0.5, 2);
       // osc3.play(midiToHz(midiSequence3[note]), 0.1);//
       // env.play(osc3, 0.5, 0.1, 0.5, 2);
       // osc4.play(midiToHz(midiSequence4[note]), 0.0);//0.2  
       // env.play(osc4, 0.5, 0.1, 0.1,2);
           
        trigger = delay + duration;

       // Sequencer
          note = note+1;
          if (note == 32) {
            note = 0;
          }
    } // trigger end
  
  
  //----- VISUAL
   
  if (delay>=0){ //if begin 
    rotateX(120+rotationSpeed);
    rotateY(120);
    rotateZ(120);
    stroke (44,43,86);
    
   } //if end
     
  
   if (delay>=240+15){ //if begin
     rotateX(120+rotationSpeed);
     rotateY(120);
     rotateZ(120);
     stroke (44,43,86);
     box(height/2);
     
   } //if end
   
   if (delay>=480+30){ //if begin
     rotateX(240-rotationSpeed);
     rotateY(300-rotationSpeed);
     rotateZ(120-rotationSpeed);   
     stroke (44,43,86);
     box(height/2);
     
   } //if end
   
   if (delay>=720+45){ //if begin
     strokeWeight(4);
     } //if end
     
   if (delay>=960+60){ //if begin
     background(44,43,86);
     stroke (255,255,255);
     noFill();
     box(height);
      } //if end
   
   if (delay>=1200+75){ //if begin
     background(44,43,86);
     stroke (255,255,255);
     noFill();
     box(height/2);
     } //if end
   
   if (delay>=1440+90){ //if begin
     rotateX(240-rotationSpeed);
     rotateY(300-rotationSpeed);
     rotateZ(120-rotationSpeed);   
     stroke (255,255,255);
     box(height/2);
     } //if end
   
   if (delay>=1680+105){ //if begin
     background(44,43,86);
     rotateX(0);
     rotateY(rotationSpeed);
     rotateZ(0);   
     stroke (44,43,86);
     fill(255,150*SinLFO);
     box(height/2);
     } //if end
 
 
 
  frameCompleted();
  
} // Display end

} //class end
class Scene05 extends Scene { //class begins

//-----VISUAL

float  r = height/3; //radius
int total = 50; // number of points
float rotationSpeed; //rotation speed
int delay;

float angle = 0;

//----- SOUND

float SinLFOin;
float SawLFOin;
int Alternator;
float Volume1;
float Volume2;

int[] midiSequence1 = {47,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/47,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0};// Lead Line 48,52,55,59,48,52,55,59,/**/55,57,55,59,54,59,55,52
int[] midiSequence2 = {40,0,40,0,40,0,40,0,/**/40,0,40,0,40,0,40,44,/**/40,0,40,0,40,0,40,0,/**/40,0,40,0,40,0,40,0};// Bass line
int[] midiSequence3 = {0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0};// Drone
int[] midiSequence4 = {0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0};// Clic

 public float midiToHz(int note) {
  return (pow(2, ((note-69)/12.0f))) * 440;
  }

int trigger = delay; 
int note = 0; 
  
Scene05 (int _sceneDuration) { // constructor begins
  sceneDuration=_sceneDuration;
  ortho();
} //cosntructor end

 public void display() { // Display begins

  background(44,43,86);
  translate(width/2,height/2);
  rotateX(0);
  rotateY(rotationSpeed);
  rotateZ(0.787f);
  rotationSpeed = rotationSpeed+0.005f ;
  delay = delay +1;
  noFill();
  stroke (241,241,160);
  strokeWeight(2);
  
   //----- SOUND
   
   int duration = 15; // 15840,7920,3960,1980,990,495,240,120
  
   SawLFOin=SawLFOin+1;    
   if (delay%240==0) { // sawLFO function Begin (saw LFO)
    SawLFOin=-0.1f*SawLFOin;
     }
     float SawLFO = map(SawLFOin, 0, 240, 0, 1);
     
   SinLFOin=(sin(delay*0.075f));
     float SinLFO = map(SinLFOin,-1,1, 1,0);
 
    if (delay%720==0) {  // Alternator Function Begin (Sqr LFO)
    Alternator = Alternator +1;
      }  
      
        if (Alternator%2==0) { //Alternator Positive
            Volume1 = 1;//1
            Volume2 = 0;        
            } else { // Alternator Negative      
              Volume1 = 0;
              Volume2 = 1;//1.5       
            } // Alternator End
      
       noise1.play();
       noise1.amp(0.05f);//0.2
       
       //osc1.play(midiToHz(midiSequence1[note]), 0.4);
      
            
  
    if ((delay > trigger) && (note<midiSequence1.length)) { // trigger begins

       
        osc1.play(midiToHz(midiSequence1[note]+12), 0.4f);//0.2
        env.play(osc1, 0.5f, 0.1f, 0.1f,2); 
        osc2.play(midiToHz(midiSequence2[note]), 0.4f);//0.1
        env.play(osc2, 0.01f, 0.1f, 0.5f, 0.01f);
        // osc3.play(midiToHz(midiSequence3[note]), 0.0);//0.2
        // env.play(osc3, 0.5, 0.1, 0.5, 2);
        // osc4.play(midiToHz(midiSequence4[note]), 0.0);//0.2 
        // env.play(osc4, 0.5, 0.1, 0.1,2);
           
        trigger = delay + duration;

       // Sequencer
          note = note+1;
          if (note == 32) {
            note = 0;
          }
    } // trigger ends

  //-----VISUAL
  
   if (delay>=0){//if begins 
    stroke(255,150*SinLFO);
    noFill();
    pushMatrix();    
    box(height);
    popMatrix();
    } //if end
    
   if (delay>=240+15){//if begin 
    fill (colorArray[colorShift],150*SinLFO);
    noStroke ();
    pushMatrix();    
    box(height/3);
    popMatrix();
    } //if end
    
   if (delay>=480+30){//if begins 
    noFill ();
    stroke (255);
    pushMatrix();    
    box(height/2);
    popMatrix();
    } //if end
            
           
    if (delay>=720+45){//if begins    
    
     background(240,81,36);
    
       float offset = 0;
   
      for (int i = 0; i < total;i = i+1){
      float lon = map(i,0,total,-PI,PI); // longitude
      for (int j = 0; j < total;j = j+1)  {
        
        float a = angle + offset;
        
        float lat = map(j,0,total,0,2); // latitude
        float x = r * sin (lon) * cos (lat+a);
        float y = r * sin (lon) * sin (lat+a);
        float z = r * cos (lon);
        
        stroke(241,241,160,255*SinLFO);
        strokeWeight(2);
        point(x,y,z);
        
        offset = offset + 0.001f;
  
   }
  
  angle = angle+ 0.001f;
   }
    } //if ends
      
  frameCompleted();
  
} // Display ends
} //class ends
class Scene06 extends Scene { //class begins

//SHAPE VARIABLES
int delay;
float rot;

//COLOR VARIABLES
float BNshift = 0;
float BNshift2 = 0;

//OFFSET VARIABLES
float t;
float theta;
int maxFrameCount = 75;
int a = 101; // offset number
int space = 200; // size of cube for for loops
float rotationSpeed;

//----- SOUND

float SinLFOin;
float SawLFOin;
int Alternator;
float Volume1;
float Volume2;

int[] midiSequence1 = {47,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/47,0,52,0,0,0,0,0,/**/0,0,0,0,0,0,0,0};//
int[] midiSequence2 = {47,47,47,47,0,0,0,0,/**/42,42,42,42,0,0,0,0,/**/47,47,47,47,0,0,0,0,/**/42,42,42,42,40,40,40,40};// 
int[] midiSequence3 = {0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0};//
int[] midiSequence4 = {40,0,40,0,40,0,40,0,/**/40,0,40,0,40,0,40,0,/**/40,0,40,0,40,0,40,0,/**/40,0,40,0,40,0,40,0};// 

 public float midiToHz(int note) {
  return (pow(2, ((note-69)/12.0f))) * 440;
  }

int trigger = delay; 
int note = 0; 

 public void shp (float x, float y,  float z, float d) {
    pushMatrix();
         translate(x,y,z);
         rotateZ(radians(rotationSpeed));
         box(d);
         popMatrix();
       
  }
  
Scene06 (int _sceneDuration) { // constructor begins
  sceneDuration=_sceneDuration;
  perspective();
  rectMode(CENTER);
} //cosntructor end


 public void display() { // Display begins

  delay = delay +1;
    
  if (delay%240==0) {
    BNshift = BNshift +1;
    BNshift2 = BNshift2 +1;
    }  

      if (BNshift%2==0) { //if else begin
        background(colorArray[colorShift5]);
      } else {
        background(44,43,86);
      } // if else end
      
      if (BNshift2%2==0) { //if else begin
        stroke(44,43,86);
        fill(44,43,86);
      } else {
        stroke(colorArray[colorShift5]);
        fill(colorArray[colorShift5]);
      } // if else end
      
   //----- SOUND
   
   int duration = 15; // 15840,7920,3960,1980,990,495,240,120
  
   SawLFOin=SawLFOin+1;    
   if (delay%240==0) { // sawLFO function Begin (saw LFO)
    SawLFOin=-0.1f*SawLFOin;
     }
     float SawLFO = map(SawLFOin, 0, 240, 0, 1);
     
   SinLFOin=(sin(delay*0.075f));
     float SinLFO = map(SinLFOin,-1,1, 1,0);
 
          
       noise1.play();
       noise1.amp(0.05f);//0.2
       
       //osc1.play(midiToHz(midiSequence1[note]), 0.4);
      
            
  
    if ((delay > trigger) && (note<midiSequence1.length)) { // trigger begins

       
        osc1.play(midiToHz(midiSequence1[note]+12), 0.4f);//0.3
        env.play(osc1, 0.5f, 0.1f, 0.1f,2);
        osc2.play(midiToHz(midiSequence2[note]), 0.4f);//0.4
        env.play(osc2, 0.05f, 0.01f, 0.5f, 0.5f);
        //osc3.play(midiToHz(midiSequence3[note]+12), 0.0);//0.1
        //env.play(osc3, 0.05, 0.01, 0.5, 0.5);
        osc4.play(midiToHz(midiSequence4[note]), 0.8f);//0.4  
        env.play(osc4, 0.01f, 0.1f, 0.5f, 0.01f);
           
        trigger = delay + duration;

       // Sequencer
          note = note+1;
          if (note == 32) {
            note = 0;
          }
    } // trigger ends
   
   //----- VISUAL
      

  translate(width/2,height/2);
  t = (float)frameCount/maxFrameCount;
  theta = TWO_PI*t/5;
  rotationSpeed = rotationSpeed+1;

  
  // rotate the whole cube
  rotateY(radians(rotationSpeed));
  rotateX(radians(45));
  rotateX(0);
  rotateZ(0);
  
// 3 nested for loops to create sides  
  for (int x = -space; x <= space; x += 200) {
  for (int y = -space; y <= space; y += 200) {
  for (int z = -space; z <= space; z += 200) {

    // map size of small cubes with offset
    float offSet = ((x*y*z))/a;
    float sz = map(sin(-theta+offSet), -1, 1, 0, 190);


   
  if ((x*y*z)%70 == 0){
    fill(colorArray[colorShift5]);
    stroke(44,43,86);
  } else {
    fill(44,43,86);
    stroke(colorArray[colorShift5]);
    
      }
    
    // small blocks, 3 times to create cube
    shp(x,y,z,sz);
    shp(y,z,x,sz);
    shp(z,x,y,sz);

    }}}
    
   
   if (delay%255==0) {  // Alternator Function Begin (Sqr LFO)
    Alternator = Alternator +1;
      }  
      
        if (Alternator%2==0) { //Alternator Positive
            rotationSpeed = 90;
            
            } else { // Alternator Negative      
              Volume1 = 0;
              Volume2 = 1;//1.5       
            } // Alternator End
    
  
       
  frameCompleted();
  
} // Display ends
} //class ends
class Scene07 extends Scene { //class begins

//SHAPE VARIABLES
int delay;
float rot;
float zAxis = -500;

//COLOR VARIABLES
float BNshift = 0;
float BNshift2 = 0;

float a=50;
float c=20;

//----- SOUND

float SinLFOin;
float SawLFOin;
int Alternator;
float Volume1;
float Volume2;

int[] midiSequence1 = {47,0,0,0,0,0,0,0,/**/47,0,0,0,0,0,0,0,/**/47,0,52,0,0,0,0,0,/**/47,0,0,0,0,0,0,0};//beep
int[] midiSequence2 = {0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0};// Bassline
int[] midiSequence3 = {55,52,59,52,60,52,59,52,/**/64,52,60,52,59,52,60,52,/**/55,52,59,52,60,52,59,52,/**/64,52,60,52,59,52,60,52};// Leadline
int[] midiSequence4 = {40,0,40,0,40,0,40,0,/**/40,0,40,0,40,0,40,0,/**/40,0,40,0,40,0,40,0,/**/40,0,40,0,40,0,40,0};// Pulse perc

 public float midiToHz(int note) {
  return (pow(2, ((note-69)/12.0f))) * 440;
  }

int trigger = delay; 
int note = 0; 

 
  
Scene07 (int _sceneDuration) { // constructor begins
  sceneDuration=_sceneDuration;
  perspective();
  rectMode(CENTER);
} //cosntructor ends


 public void display() { // Display begins
    delay = delay +1;
    
     //----- SOUND
   
   int duration = 15; // 15840,7920,3960,1980,990,495,240,120
  
   SawLFOin=SawLFOin+1;    
   if (delay%240==0) { // sawLFO function Begin (saw LFO)
    SawLFOin=-0.1f*SawLFOin;
     }
     float SawLFO = map(SawLFOin, 0, 240, 0, 1);
     
   SinLFOin=(sin(delay*0.075f));
     float SinLFO = map(SinLFOin,-1,1, 1,0);
 
    if (delay%240==0) {  // Alternator Function Begin (Sqr LFO)
    Alternator = Alternator +1;
      }  
      
        if (Alternator%2==0) { //Alternator Positive
            Volume1 = 1;//1
            Volume2 = 0;        
            } else { // Alternator Negative      
              Volume1 = 0;
              Volume2 = 1;//1.5       
            } // Alternator End
      
       noise1.play();
       noise1.amp(0.05f);//0.2
       
       //osc1.play(midiToHz(midiSequence1[note]), 0.4);
      
            
  
    if ((delay > trigger) && (note<midiSequence1.length)) { // trigger begins

       
        osc1.play(midiToHz(midiSequence1[note]+12), 0.4f);//0.3
        env.play(osc1, 0.5f, 0.1f, 0.1f,2);
        osc2.play(midiToHz(midiSequence2[note]), 0.0f);//0.4
        env.play(osc2, 0.05f, 0.01f, 0.5f, 0.5f);
        osc3.play(midiToHz(midiSequence3[note]+12), 0.2f);//0.1
        env.play(osc3, 0.05f, 0.01f, 0.5f, 0.5f);
        osc4.play(midiToHz(midiSequence4[note]), 0.4f);//0.4  
        env.play(osc4, 0.01f, 0.1f, 0.5f, 0.01f);
           
        trigger = delay + duration;

       // Sequencer
          note = note+1;
          if (note == 32) {
            note = 0;
          }
    } // trigger ends
    
    //-----VISUAL
    
    zAxis = zAxis +5;
    if (zAxis > 750){
        zAxis = -750;
      }
    rot = rot + 0.01f;
    rotateZ(rot);
    rotateY(rot);
 
  if (frameCount%60==0) {
    BNshift = BNshift +1;
    BNshift2 = BNshift2 +1;
    }  
    
     // background(44,43,86);
      //stroke(colorArray[colorShift2]);
      
      
        if (BNshift%2==0) { //if else begins
        background(colorArray[colorShift],SinLFO);
        stroke(44,43,86);
      } else {
        background(44,43,86);
        stroke(colorArray[colorShift]);
      } // if else end
      
      
      pushMatrix();
      translate(width/2,height/2,zAxis);
      rotateY(rot);
      rotateX(rot);
      box(600);
      popMatrix();
            
      pushMatrix();
      translate(width/2,height/2,2*zAxis);
      rotateY(rot);
      rotateX(rot);
      box(600);
      popMatrix();
            
      pushMatrix();
      translate(width/2,height/2,4*zAxis);
      rotateY(rot);
      rotateX(rot);
      box(600);
      popMatrix();
      
      
      pushMatrix();
      translate(width/2,height/2,6*zAxis);
      rotateY(rot);
      rotateX(rot);
      box(600);
      popMatrix();
      
      pushMatrix();
      translate(width/2,height/2,8*zAxis);
      rotateY(rot);
      rotateX(rot);
      box(600);
      popMatrix();

     
  frameCompleted();
  
} // Display ends
} //class ends
class Scene08 extends Scene { //class begins 

int grow;
int delay;
float rot;

//----- SOUND

float SinLFOin;
float SawLFOin;
int Alternator;
float Volume1;
float Volume2;

int[] midiSequence1 = {47,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0};//beep
int[] midiSequence2 = {47,47,47,47,0,0,0,0,/**/42,42,42,42,0,0,0,0,/**/47,47,47,47,0,0,0,0,/**/42,42,42,42,40,40,40,40};// Bassline
int[] midiSequence3 = {55,52,59,52,60,52,59,52,/**/64,52,60,52,59,52,60,52,/**/55,52,59,52,60,52,59,52,/**/64,52,60,52,59,52,60,52};// Leadline
int[] midiSequence4 = {0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0};// Pulse perc

 public float midiToHz(int note) {
  return (pow(2, ((note-69)/12.0f))) * 440;
  }

int trigger = delay; 
int note = 0; 

  
Scene08(int _sceneDuration) { // constructor begins
  sceneDuration=_sceneDuration;
  ortho();
} //cosntructor ends

 public void display() {  // function begins
  
  delay = delay +1;

 //----- SOUND
   
   int duration = 30; // 15840,7920,3960,1980,990,495,240,120
  
   SawLFOin=SawLFOin+1;    
   if (delay%240==0) { // sawLFO function Begin (saw LFO)
    SawLFOin=-0.1f*SawLFOin;
     }
     float SawLFO = map(SawLFOin, 0, 240, 0, 1);
     
   SinLFOin=(sin(delay*0.075f));
     float SinLFO = map(SinLFOin,-1,1, 1,0);
 
    if (delay%240==0) {  // Alternator Function Begin (Sqr LFO)
    Alternator = Alternator +1;
      }  
      
        if (Alternator%2==0) { //Alternator Positive
            Volume1 = 1;//1
            Volume2 = 0;        
            } else { // Alternator Negative      
              Volume1 = 0;
              Volume2 = 1;//1.5       
            } // Alternator End
      
       noise1.play();
       noise1.amp(0.05f);//0.2
       
       //osc1.play(midiToHz(midiSequence1[note]), 0.4);
      
            
  
    if ((delay > trigger) && (note<midiSequence1.length)) { // trigger begins

       
        osc1.play(midiToHz(midiSequence1[note]+12), 0.4f);//0.3
        env.play(osc1, 0.5f, 0.1f, 0.1f,2);
        osc2.play(midiToHz(midiSequence2[note]), 0.6f);//0.4
        env.play(osc2, 0.05f, 0.01f, 0.5f, 0.5f);
        osc3.play(midiToHz(midiSequence3[note]+12), 0.2f);//0.1
        env.play(osc3, 0.05f, 0.01f, 0.5f, 0.5f);
        osc4.play(midiToHz(midiSequence4[note]), 0.4f);//0.4  
        env.play(osc4, 0.01f, 0.1f, 0.5f, 0.01f);
           
        trigger = delay + duration;

       // Sequencer
          note = note+1;
          if (note == 32) {
            note = 0;
          }
    } // trigger ends



//----- VISUAL


  background(44,43,86); 
    
    rot = rot + 0.01f;
   // grow = grow +1;
    delay = delay +1;
    strokeWeight(2);
    
  
    
    if (delay>=240){
      pushMatrix();
      translate(width/2,height/2);
      rotateY(rot);
      rotateX(rot);
      noFill();
      stroke(255);
      box(900);
      popMatrix();
      } 
      
    if (delay>=480){
      pushMatrix();
      translate(width/2,height/2);
      rotateY(rot*1.02f);
      rotateX(rot);
      noFill();
      stroke(255);
      box(750);
      popMatrix();
      }
    if (delay>=720){
      pushMatrix();
      translate(width/2,height/2);
      rotateY(rot*1.04f);
      rotateX(rot);
      noFill();
      stroke(255);
      box(600);
      popMatrix();
      } 
      
     if (delay>=990){
      pushMatrix();
      translate(width/2,height/2);
      rotateY(rot*1.06f);
      rotateX(rot);
      noFill();
      stroke(255);
      box(450);
      popMatrix();
      }
      
     if (delay>=1230){
      pushMatrix();
      translate(width/2,height/2);
      rotateY(rot*1.08f);
      rotateX(rot);
      noFill();
      stroke(255);
      box(300);
      popMatrix();
      }
      
      if (delay>=1470){
      pushMatrix();
      translate(width/2,height/2);
      rotateY(rot*1.1f);
      rotateX(rot);
      noFill();
      stroke(255);
      box(150);
      popMatrix();
      }  
      
      
  frameCompleted();
} // Function ends

} //class ends
class Scene09 extends Scene { //class begins

//SHAPE VARIABLES
int delay;
float rot;

//COLOR VARIABLES
float BNshift = 0;
float BNshift2 = 0;

//OFFSET VARIABLES
float t;
float theta;
int maxFrameCount = 75;
int a = 101; // offset number
int space = 100; // size of cube for loops
float rotationSpeed;

//----- SOUND

float SinLFOin;
float SawLFOin;
int Alternator;
float Volume1;
float Volume2;

int[] midiSequence1 = {55,52,59,52,60,52,59,52,/**/64,52,60,52,59,52,60,52,/**/55,52,59,52,60,52,59,52,/**/64,52,60,52,59,52,60,52};// lead line
int[] midiSequence2 = {47,47,47,47,0,0,0,0,/**/42,42,42,42,0,0,0,0,/**/47,47,47,47,0,0,0,0,/**/42,42,42,42,40,40,40,40};// bassline
int[] midiSequence3 = {52,52,52,52,55,55,55,55,/**/47,47,47,47,55,55,55,55,/**/52,52,52,52,55,55,55,55,/**/48,48,48,48,55,55,55,55};// pad 1
int[] midiSequence4 = {40,40,40,40,42,42,42,42,/**/35,35,35,35,43,43,43,43,/**/52,52,52,52,52,52,52,52,/**/35,35,35,35,43,43,43,43};// pad 2

 public float midiToHz(int note) {
  return (pow(2, ((note-69)/12.0f))) * 440;
  }

int trigger = delay; 
int note = 0; 

 public void shp (float x, float y,  float z, float d) {
    pushMatrix();
         translate(x,y,z);
         rotateZ(radians(rotationSpeed));
         box(d);
         popMatrix();
       
  }
  
Scene09 (int _sceneDuration) { // constructor begins
  sceneDuration=_sceneDuration;
  perspective();
  rectMode(CENTER);
} //cosntructor ends


 public void display() { // Display begins

     delay = delay +1;
    
    //----- SOUND
   
   int duration = 15; // 15840,7920,3960,1980,990,495,240,120
  
   SawLFOin=SawLFOin+1;    
   if (delay%240==0) { // sawLFO function Begin (saw LFO)
    SawLFOin=-0.1f*SawLFOin;
     }
     float SawLFO = map(SawLFOin, 0, 240, 0, 1);
     
   SinLFOin=(sin(delay*0.075f));
     float SinLFO = map(SinLFOin,-1,1, 1,0);
 
    if (delay%240==0) {  // Alternator Function Begin (Sqr LFO)
    Alternator = Alternator +1;
      }  
      
        if (Alternator%2==0) { //Alternator Positive
            Volume1 = 1;//1
            Volume2 = 0;        
            } else { // Alternator Negative      
              Volume1 = 0;
              Volume2 = 1;//1.5       
            } // Alternator End
      
       noise1.play();
       noise1.amp(0.05f);//0.2
       
       //osc1.play(midiToHz(midiSequence1[note]), 0.4);
      
            
  
    if ((delay > trigger) && (note<midiSequence1.length)) { // trigger begin

       
        osc1.play(midiToHz(midiSequence1[note]+12), 0.2f);//0.3
        env.play(osc1, 0.05f, 0.01f, 0.5f, 0.5f);
        osc2.play(midiToHz(midiSequence2[note]), 0.4f);//0.4
        env.play(osc2, 0.05f, 0.01f, 0.5f, 0.5f);
        osc3.play(midiToHz(midiSequence3[note]), 0.4f);//0.1
        //env.play(osc3, 0.05, 0.01, 0.5, 0.5);
        osc4.play(midiToHz(midiSequence4[note]), 0.4f);//0.4  
        //env.play(osc4, 0.01, 0.1, 0.5, 0.01);
           
        trigger = delay + duration;

       // Sequencer
          note = note+1;
          if (note == 32) {
            note = 0;
          }
    } // trigger ends


//----- VISUAL

  if (frameCount%30==0) {
    BNshift = BNshift +1;
    BNshift2 = BNshift2 +1;
    }  

      if (BNshift%2==0) { //if else begins
        background(241,228,126);
      } else {
        background(44,43,86);
      } // if else end
      
      if (BNshift2%2==0) { //if else begins
        stroke(44,43,86);
        fill(44,43,86);
      } else {
        stroke(241,228,126);
        fill(241,228,126);
      } // if else end
      
      

  translate(width/2,height/2);
  t = (float)frameCount/maxFrameCount;
  theta = TWO_PI*t/5;
  rotationSpeed = rotationSpeed+1;

  
  // rotate the whole cube
  rotateY(radians(rotationSpeed));
 // rotateX(radians(45));
  rotateX(0);
  rotateZ(0);
  
// 3 nested for loops to create sides  
  for (int x = -space; x <= space; x += 200) {
  for (int y = -space; y <= space; y += 200) {
  for (int z = -space; z <= space; z += 400) {

    // map size of small cubes with offset
    float offSet = ((x*y*z))/a;
    float sz = map(sin(-theta+offSet), -1, 1, 0, 100);


   
  if ((x*y*z)%70 == 0){
    fill(241,228,126);
    stroke(44,43,86);
  } else {
    fill(44,43,86);
    stroke(241,228,126);
      }
    
    // small blocks, 3 times to create cube
    shp(x,y,z,sz);
    shp(y,z,x,sz);
    shp(z,x,y,sz);

    }}}
    
  frameCompleted();
  
} // Display ends
} //class ends
class Scene10 extends Scene { //class begins

int grow;
int delay;
float rot;

//----- SOUND

float SinLFOin;
float SawLFOin;
int Alternator;
float Volume1;
float Volume2;

int[] midiSequence1 = {40,43,47,52,55,59,40,43,/**/47,52,55,59,40,43,47,47,/**/40,43,47,52,55,59,40,43,/**/47,52,55,59,40,43,47,47};// lead line
int[] midiSequence2 = {47,47,47,47,0,0,0,0,/**/42,42,42,42,0,0,0,0,/**/47,47,47,47,0,0,0,0,/**/42,42,42,42,40,40,40,40};// bassline
int[] midiSequence3 = {47,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0};// pad 1
int[] midiSequence4 = {40,40,40,40,42,42,42,42,/**/35,35,35,35,43,43,43,43,/**/40,40,40,40,42,42,42,42,/**/35,35,35,35,36,38,40,43};// pad 2

 public float midiToHz(int note) {
  return (pow(2, ((note-69)/12.0f))) * 440;
  }

int trigger = delay; 
int note = 0; 
  
Scene10(int _sceneDuration) { // constructor begins
  sceneDuration=_sceneDuration;
  ortho();
} //cosntructor ends

 public void display() {  // function begin

 delay = delay +1;
    
 //----- SOUND
   
   int duration = 15; // 15840,7920,3960,1980,990,495,240,120
  
   SawLFOin=SawLFOin+1;    
   if (delay%240==0) { // sawLFO function Begin (saw LFO)
    SawLFOin=-0.1f*SawLFOin;
     }
     float SawLFO = map(SawLFOin, 0, 240, 0, 1);
     
   SinLFOin=(sin(delay*0.075f));
     float SinLFO = map(SinLFOin,-1,1, 1,0);
 
    if (delay%240==0) {  // Alternator Function Begin (Sqr LFO)
    Alternator = Alternator +1;
      }  
      
        if (Alternator%2==0) { //Alternator Positive
            Volume1 = 1;//1
            Volume2 = 0;        
            } else { // Alternator Negative      
              Volume1 = 0;
              Volume2 = 1;//1.5       
            } // Alternator End
      
       noise1.play();
       noise1.amp(0.05f);//0.2
       
       //osc1.play(midiToHz(midiSequence1[note]), 0.4);
      
            
  
    if ((delay > trigger) && (note<midiSequence1.length)) { // trigger begins

       
        osc1.play(midiToHz(midiSequence1[note]+12), 0.2f);//0.3
        env.play(osc1, 0.05f, 0.01f, 0.5f, 0.5f);
        osc2.play(midiToHz(midiSequence2[note]), 0.8f);//0.4
        env.play(osc2, 0.01f, 0.01f, 0.5f, 0.1f);
        osc3.play(midiToHz(midiSequence3[note]), 0.4f);//0.1
        env.play(osc3, 0.05f, 0.01f, 0.5f, 0.5f);
        osc4.play(midiToHz(midiSequence4[note]+12), 0.4f);//0.4  
        //env.play(osc4, 0.01, 0.1, 0.5, 0.01);
           
        trigger = delay + duration;

       // Sequencer
          note = note+1;
          if (note == 32) {
            note = 0;
          }
    } // trigger ends
    
//----- VISUAL

  background(44,43,86); 
    
    rot = rot + 0.01f;
   // grow = grow +1;
    strokeWeight(2);
    
  
    
    if (delay>=120){
      pushMatrix();
      translate(width/2,height/2);
      rotateY(rot);
      rotateX(rot);
      noFill();
      stroke(241,228,126);
      box(100);
      popMatrix();
      } 
      
    if (delay>=240+15){
      pushMatrix();
      translate(width/2,height/2);
      rotateY(rot);
      rotateX(rot);
      noFill();
      stroke(245,166,31);
      box(200);
      popMatrix();
      }
    if (delay>=360+15){
      pushMatrix();
      translate(width/2,height/2);
      rotateY(rot);
      rotateX(rot);
      noFill();
      stroke(240,81,36);
      box(300);
      popMatrix();
      } 
      
     if (delay>=480+30){
      pushMatrix();
      translate(width/2,height/2);
      rotateY(rot);
      rotateX(rot);
      noFill();
      stroke(185,44,58);
      box(400);
      popMatrix();
      }
      
     if (delay>=600+30){
      pushMatrix();
      translate(width/2,height/2);
      rotateY(rot);
      rotateX(rot);
      noFill();
      stroke(55,139,189);
      box(500);
      popMatrix();
      }
      
      if (delay>=720+45){
      background (55,139,189);
      pushMatrix();
      translate(width/2,height/2);
      rotateY(rot);
      rotateX(rot);
      //fill(250,250,250,150);
      stroke(250);
      box(500);
      popMatrix();
      
      }     
   
  frameCompleted();
} // Function ends

} //class ends
class Scene11 extends Scene { //class begins

//SHAPE VARIABLES
int delay;
float rot;
float zAxis = -500;

//COLOR VARIABLES
float BNshift = 0;
float BNshift2 = 0;

float a=50;
float c=20;

//----- SOUND

float SinLFOin;
float SawLFOin;
int Alternator;
float Volume1;
float Volume2;

int[] midiSequence1 = {40,43,47,52,55,59,40,43,/**/47,52,55,59,40,43,47,47,/**/40,43,47,52,55,59,40,43,/**/47,52,55,59,40,43,47,47};// lead line
int[] midiSequence2 = {0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0};// bassline
int[] midiSequence3 = {52,52,52,52,55,55,55,55,/**/47,47,47,47,55,55,55,55,/**/52,52,52,52,55,55,55,55,/**/48,48,48,48,55,55,55,55};// pad 1
int[] midiSequence4 = {55,52,59,52,60,52,59,52,/**/64,52,60,52,59,52,60,52,/**/55,52,59,52,60,52,59,52,/**/64,52,60,52,59,52,60,52};// lead Line 2

 public float midiToHz(int note) {
  return (pow(2, ((note-69)/12.0f))) * 440;
  }

int trigger = delay; 
int note = 0; 
 
  
Scene11 (int _sceneDuration) { // constructor begins
  sceneDuration=_sceneDuration;
  perspective();
  rectMode(CENTER);
} //cosntructor end


 public void display() { // Display begins

 delay = delay +1; // 
 rot = QUARTER_PI;

 //----- SOUND
   
   int duration = 15; // 15840,7920,3960,1980,990,495,240,120
  
   SawLFOin=SawLFOin+1;    
   if (delay%240==0) { // sawLFO function Begin (saw LFO)
    SawLFOin=-0.1f*SawLFOin;
     }
     float SawLFO = map(SawLFOin, 0, 240, 0, 1);
     
   SinLFOin=(sin(delay*0.075f));
     float SinLFO = map(SinLFOin,-1,1, 1,0);
 
    if (delay%240==0) {  // Alternator Function Begin (Sqr LFO)
    Alternator = Alternator +1;
      }  
      
        if (Alternator%2==0) { //Alternator Positive
            Volume1 = 1;//1
            Volume2 = 0;        
            } else { // Alternator Negative      
              Volume1 = 0;
              Volume2 = 1;//1.5       
            } // Alternator Ends
      
       noise1.play();
       noise1.amp(0.05f);//0.2
       
       //osc1.play(midiToHz(midiSequence1[note]), 0.4);
      
            
  
    if ((delay > trigger) && (note<midiSequence1.length)) { // trigger begins

       
        osc1.play(midiToHz(midiSequence1[note]+12), 0.4f);//0.3
        env.play(osc1, 0.1f, 0.01f, 0.5f, 0.5f);
        osc2.play(midiToHz(midiSequence2[note]), 0.4f);//0.4
        env.play(osc2, 0.05f, 0.01f, 0.5f, 0.5f);
        osc3.play(midiToHz(midiSequence3[note]), 0.0f);//0.1
       // env.play(osc3, 0.05, 0.01, 0.5, 0.5);
        osc4.play(midiToHz(midiSequence4[note]), 0.4f);//0.4  
       // env.play(osc4, 0.01, 0.1, 0.5, 0.01);
           
        trigger = delay + duration;

       // Sequencer
          note = note+1;
          if (note == 32) {
            note = 0;
          }
    } // trigger ends
    
    
 //-----VISUAL
 
    zAxis = zAxis +5;
    if (zAxis > 750){
        zAxis = -750;
      }
 
  if (frameCount%30==0) {
    BNshift = BNshift +1;
    BNshift2 = BNshift2 +1;
    }  
    
     // background(44,43,86);
      //stroke(colorArray[colorShift2]);
      
      
      if (BNshift%2==0) { //if else begin
        background(colorArray[colorShift2]);
      } else {
        background(44,43,86);
      } // if else end
      
      if (BNshift2%2==0) { //if else begin
        stroke(44,43,86);
       } else {
        stroke(colorArray[colorShift2]);
       } // if else end
      
      
      pushMatrix();
      translate(width/2,height/2,zAxis);
      rotateZ(rot);
      box(400);
      popMatrix();
      
      if (delay>=240+15){
      pushMatrix();
      translate(width/2,height/2,2*zAxis);
      rotateZ(rot);
      box(400);
      popMatrix();
      }
      
       if (delay>=480+30){
      pushMatrix();
      translate(width/2,height/2,4*zAxis);
      rotateZ(rot);
      box(400);
      popMatrix();
      }
      
       if (delay>=720+45){
      pushMatrix();
      translate(width/2,height/2,6*zAxis);
      rotateZ(rot);
      box(400);
      popMatrix();
      }   
      
       if (delay>=960+60){
      pushMatrix();
      translate(width/2,height/2,8*zAxis);
      rotateZ(rot);
      box(400);
      popMatrix();
      } 
      
  frameCompleted();
  
} // Display ends
} //class ends
class Scene12 extends Scene { //class begin

//SHAPE VARIABLES
float  r = height/3; //radius
int total = 50; // number of points
float rotationSpeed; //rotation speed
int delay;

//----- SOUND

float SinLFOin;
float SawLFOin;
int Alternator;
float Volume1;
float Volume2;

int[] midiSequence1 = {40,43,47,52,55,59,40,43,/**/47,52,55,59,40,43,47,47,/**/40,43,47,52,55,59,40,43,/**/47,52,55,59,40,43,47,47};// lead line
int[] midiSequence2 = {47,47,47,47,0,0,0,0,/**/42,42,42,42,0,0,0,0,/**/47,47,47,47,0,0,0,0,/**/42,42,42,42,40,40,40,40};// bassline
int[] midiSequence3 = {52,52,52,52,55,55,55,55,/**/47,47,47,47,55,55,55,55,/**/52,52,52,52,55,55,55,55,/**/47,47,47,47,55,55,55,55};// pad 1
int[] midiSequence4 = {40,40,40,40,42,42,42,42,/**/35,35,35,35,43,43,43,43,/**/40,40,40,40,42,42,42,42,/**/35,35,35,35,36,38,40,43};// pad 2

 public float midiToHz(int note) {
  return (pow(2, ((note-69)/12.0f))) * 440;
  }

int trigger = delay; 
int note = 0; 
  
Scene12(int _sceneDuration) { // constructor begins
  sceneDuration=_sceneDuration;
  ortho();
} //cosntructor ends

 public void display() { // Display begins

delay = delay +1;

//----- SOUND
   
   int duration = 15; // 15840,7920,3960,1980,990,495,240,120
  
   SawLFOin=SawLFOin+1;    
   if (delay%255==0) { // sawLFO function Begin (saw LFO)
    SawLFOin=-0.1f*SawLFOin;
     }
     float SawLFO = map(SawLFOin, 0, 240, 0, 1);
     
   SinLFOin=(sin(delay*0.025f));
     float SinLFO = map(SinLFOin,-1,1, 1,0);
 
    if (delay%255==0) {  // Alternator Function Begin (Sqr LFO)
    Alternator = Alternator +1;
      }  
      
        if (Alternator%2==0) { //Alternator Positive
            Volume1 = 1;//1
            Volume2 = 0;        
            } else { // Alternator Negative      
              Volume1 = 0;
              Volume2 = 1;//1.5       
            } // Alternator End
      
       noise1.play();
       noise1.amp(0.05f);//0.2
       
       //osc1.play(midiToHz(midiSequence1[note]), 0.4);
      
            
  
    if ((delay > trigger) && (note<midiSequence1.length)) { // trigger begin

       
        osc1.play(midiToHz(midiSequence1[note]+12), 0.4f);//0.3
        env.play(osc1, 0.1f, 0.01f, 0.5f, 0.05f);
        osc2.play(midiToHz(midiSequence2[note]), 0.0f);//0.4
        env.play(osc2, 0.05f, 0.01f, 0.5f, 0.5f);
        osc3.play(midiToHz(midiSequence3[note]), 0.0f);//0.1
        //env.play(osc3, 0.05, 0.01, 0.5, 0.5);
        osc4.play(midiToHz(midiSequence4[note]+12), 0.4f);//0.4  
        //env.play(osc4, 0.01, 0.1, 0.5, 0.05);
           
        trigger = delay + duration;

       // Sequencer
          note = note+1;
          if (note == 32) {
            note = 0;
          }
    } // trigger ends
    
    //-----VISUAL

  background(44,43,86);
  translate(width/2,height/2);
  rotateX(rotationSpeed*4);
  rotateY(120);
  rotateZ(rotationSpeed);
  rotationSpeed = rotationSpeed+0.005f ;
  
   
    float offset = 0;
   
      for (int i = 0; i < total;i = i+1){
      float lon = map(i,0,total,-PI,PI); // longitude
      for (int j = 0; j < total;j = j+1)  {
        
                
        float lat = map(j,0,total,-HALF_PI,HALF_PI); // latitude
        float x = r * sin (lon*SinLFO) * cos (lat) +200;
        float y = r * sin (lon) * sin (lat*SinLFO) +200;
        float z = r * -cos (lon*SinLFO);
        
        stroke(colorArray[colorShift]);
        strokeWeight(3);
        point(x,y,z);
        
           offset = offset + 0.01f;
  
       }
       }
   
   for (int i = 0; i < total;i = i+1){
      float lon = map(i,0,total,-PI,PI); // longitude
      for (int j = 0; j < total;j = j+1)  {
        
                
        float lat = map(j,0,total,-HALF_PI,HALF_PI); // latitude
        float x = r * sin (lon*SinLFO) * cos (lat) -200;
        float y = r * sin (lon) * sin (lat*SinLFO) -200;
        float z = r * cos (lon*SinLFO);
        
        stroke(colorArray[colorShift]);
        strokeWeight(3);
        point(x,y,z);
        
           offset = offset + 0.01f;
  
        }
        }
 
   
   
     
  frameCompleted();
  
} // Display ends
} //class ends
class Scene13 extends Scene { //class begins

//SHAPE VARIABLES
int delay;
float rot;

//COLOR VARIABLES
float BNshift = 0;
float BNshift2 = 0;

//OFFSET VARIABLES
float t;
float theta;
int maxFrameCount = 75;
int a = 101; // offset number
int space = 300; // size of cube for for loops
float rotationSpeed;

//----- SOUND

float SinLFOin;
float SawLFOin;
int Alternator;
float Volume1;
float Volume2;

int[] midiSequence1 = {52,52,52,52,52,52,52,52,/**/52,52,52,52,52,52,52,52,/**/52,52,52,52,52,52,52,52,/**/52,52,52,52,52,52,52,52};// lead line
int[] midiSequence2 = {40,0,40,0,40,0,40,0,/**/40,0,40,0,40,0,40,0,/**/40,0,40,0,40,0,40,0,/**/40,0,40,0,40,0,40,0};// bassline
int[] midiSequence3 = {0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0};// pad 1
int[] midiSequence4 = {0,0,0,64,0,0,0,64,/**/0,0,0,64,0,0,0,64,/**/0,0,0,64,0,0,0,64,/**/0,0,0,64,0,0,0,64};// lead Line 2

 public float midiToHz(int note) {
  return (pow(2, ((note-69)/12.0f))) * 440;
  }

int trigger = delay; 
int note = 0; 

 public void shp (float x, float y,  float z, float d) {
    pushMatrix();
         translate(x,y,z);
         rotateZ(radians(rotationSpeed));
         box(d);
         popMatrix();
       
  }
  
Scene13 (int _sceneDuration) { // constructor begins
  sceneDuration=_sceneDuration;
  perspective();
  rectMode(CENTER);
} //cosntructor ends


 public void display() { // Display begins


delay = delay +1;
strokeWeight(1);

//----- SOUND
   
   int duration = 15; // 15840,7920,3960,1980,990,495,240,120
  
   SawLFOin=SawLFOin+1;    
   if (delay%240==0) { // sawLFO function Begin (saw LFO)
    SawLFOin=-0.1f*SawLFOin;
     }
     float SawLFO = map(SawLFOin, 0, 240, 0, 1);
     
   SinLFOin=(sin(delay*0.075f));
     float SinLFO = map(SinLFOin,-1,1, 1,0);
 
    if (delay%240==0) {  // Alternator Function Begin (Sqr LFO)
    Alternator = Alternator +1;
      }  
      
        if (Alternator%2==0) { //Alternator Positive
            Volume1 = 1;//1
            Volume2 = 0;        
            } else { // Alternator Negative      
              Volume1 = 0;
              Volume2 = 1;//1.5       
            } // Alternator Ends
      
       noise1.play();
       noise1.amp(0.05f);//0.2
       
       //osc1.play(midiToHz(midiSequence1[note]), 0.4);
      
            
  
    if ((delay > trigger) && (note<midiSequence1.length)) { // trigger begins

       
        osc1.play(midiToHz(midiSequence1[note]+12), 0.6f);//0.3
        env.play(osc1, 0.05f, 0.01f, 0.5f, 0.05f);
        osc2.play(midiToHz(midiSequence2[note]), 0.2f);//0.4
        env.play(osc2, 0.05f, 0.01f, 0.5f, 0.05f);
        osc3.play(midiToHz(midiSequence3[note]), 0.0f);//0.1
        env.play(osc3, 0.05f, 0.01f, 0.5f, 0.05f);
        osc4.play(midiToHz(midiSequence4[note]+12), 0.2f);//0.4  
        env.play(osc4, 0.05f, 0.01f, 0.5f, 0.05f);
           
        trigger = delay + duration;

       // Sequencer
          note = note+1;
          if (note == 32) {
            note = 0;
          }
    } // trigger ends
    
    //-----VISUAL
    
  if (frameCount%30==0) {
    BNshift = BNshift +1;
    BNshift2 = BNshift2 +1;
    }  

      if (BNshift%2==0) { //if else begins
        background(colorArray[colorShift2]);
      } else {
        background(44,43,86);
      } // if else end
      
      if (BNshift2%2==0) { //if else begins
        stroke(44,43,86);
        fill(44,43,86);
      } else {
        stroke(colorArray[colorShift2]);
        fill(colorArray[colorShift2]);
      } // if else end
      
      

  translate(width/2,height/2);
  t = (float)frameCount/maxFrameCount;
  theta = TWO_PI*t/5;
  rotationSpeed = rotationSpeed+1;

  
  // rotate the whole cube
  rotateY(radians(rotationSpeed));
 // rotateX(radians(45));
  rotateX(0);
  rotateZ(0);
  
// 3 nested for loops to create sides  
  for (int x = -space; x <= space; x += 200) {
  for (int y = -space; y <= space; y += 200) {
  for (int z = -space; z <= space; z += 400) {

    // map size of small cubes with offset
    float offSet = ((x*y*z))/a;
    float sz = map(sin(-theta+offSet), -1, 1, 0, 100);


   
  if ((x*y*z)%70 == 0){
    fill(colorArray[colorShift2]);
    stroke(44,43,86);
  } else {
    fill(44,43,86);
    stroke(colorArray[colorShift2]);
      }
    
    // small blocks, 3 times to create cube
    shp(x,y,z,sz);
    shp(y,z,x,sz);
    shp(z,x,y,sz);

    }}}
     
  frameCompleted();
  
} // Display ends
} //class ends
//FInal credits
class Scene14 extends Scene {  // class begins
PFont[] titleFont=new PFont[5];
int delay;
String title1="</ritmo 2021>";
String title2="/*\n The images and sounds of this audiovisual prototype \n were generated entirely through the use of the \n Processing programming language \n */";
String title3_1="Directing[] = { \n   Luscus == (Luis Fernando Medina Cardona); \n   Bonnie == (Julian David Sandoval Ospina); \n}";
String title3_2="Coding[] = { \n   Bonnie; \n   Luscus; \n}";
String title3_3="MusicComposing[] = { \n   Bonnie; \n}";
String title3_4="/* Ritmo 2021: production of an experimental short film using computer programming  \nProject funded by the research-creation projects 2020 calling \nFaculty of Arts, Universidad Nacional de Colombia (Bogotá campus) */"; 
String title5 = "</espam> : Open Media Production Space \nCreative Research Group \nFaculty of Arts, Universidad Nacional de Colombia \n(Bogotá Campus)";
PImage logo1;
PImage logo2;
//----- SOUND

float SinLFOin;
float SawLFOin;
int Alternator;
float Volume1;
float Volume2;

int[] midiSequence1 = {52,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,02};// lead line
int[] midiSequence2 = {40,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,00};// bassline
int[] midiSequence3 = {0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0};// pad 1
int[] midiSequence4 = {64,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0,/**/0,0,0,0,0,0,0,0};// lead Line 2

 public float midiToHz(int note) {
  return (pow(2, ((note-69)/12.0f))) * 440;
  }

int trigger = delay; 
int note = 0; 


Scene14(int _sceneDuration){
  sceneDuration=_sceneDuration;
  titleFont[0] = createFont("UbuntuMono-R.ttf",height*0.04f);
  titleFont[1]= createFont("SourceCodePro-Regular.ttf",height*0.03f);
  titleFont[2]= createFont("SourceCodePro-Regular.ttf",height*0.028f);
  titleFont[3]= createFont("SourceCodePro-Regular.ttf",height*0.025f);
  logo1=loadImage("logoespam.png");
  logo2=loadImage("logounal.png");
  //titleFonm[4]= 
} //cosntructor ends


 public void display () {
  
  delay = delay +1;

//----- SOUND
   
   int duration = 120; // 15840,7920,3960,1980,990,495,240,120
  
   SawLFOin=SawLFOin+1;    
   if (delay%240==0) { // sawLFO function Begin (saw LFO)
    SawLFOin=-0.1f*SawLFOin;
     }
     float SawLFO = map(SawLFOin, 0, 240, 0, 1);
     
   SinLFOin=(sin(delay*0.075f));
     float SinLFO = map(SinLFOin,-1,1, 1,0);
 
    if (delay%240==0) {  // Alternator Function Begin (Sqr LFO)
    Alternator = Alternator +1;
      }  
      
        if (Alternator%2==0) { //Alternator Positive
            Volume1 = 1;//1
            Volume2 = 0;        
            } else { // Alternator Negative      
              Volume1 = 0;
              Volume2 = 1;//1.5       
            } // Alternator End
      
       noise1.play();
       noise1.amp(0.05f);//0.2
       
       //osc1.play(midiToHz(midiSequence1[note]), 0.4);
      
            
  
    if ((delay > trigger) && (note<midiSequence1.length)) { // trigger begin

       
        osc1.play(midiToHz(midiSequence1[note]+12), 0.6f);//0.3
        env.play(osc1, 0.05f, 0.01f, 0.5f, 0.05f);
        osc2.play(midiToHz(midiSequence2[note]), 0.2f);//0.4
        env.play(osc2, 0.05f, 0.01f, 0.5f, 0.05f);
        osc3.play(midiToHz(midiSequence3[note]), 0.0f);//0.1
        env.play(osc3, 0.05f, 0.01f, 0.5f, 0.05f);
        osc4.play(midiToHz(midiSequence4[note]+12), 0.2f);//0.4  
        env.play(osc4, 0.05f, 0.01f, 0.5f, 0.05f);
           
        trigger = delay + duration;

       // Sequencer
          note = note+1;
          if (note == 32) {
            note = 0;
          }
    } // trigger end
    
    
  //-----VISUAL
  
  //Credits last 1700 frames: 1. short film abstract 2. credits  3. this is a research project 4. logos.
    
   
  background(44,43,86);    
  if(sceneDuration<1700 && sceneDuration>1500){  
     pushMatrix();
     translate(width/2,height/2);
     textAlign(CENTER);
     textFont(titleFont[0]);
     fill(colorArray[3]);
     text(title1,0,10);
     popMatrix();}
  else if (sceneDuration<1500 && sceneDuration >1200){
    // pushMatrix();
    // translate(width/4,height/4);
     rectMode(CENTER);
     textAlign(LEFT);
     textFont(titleFont[1]);
     fill(0xFFEBEAF3);
     textLeading(height*0.04f);
     text(title2,width/2,height/2,width*3/4,height/3);
   //  popMatrix();}
    }
  else if (sceneDuration<1200 && sceneDuration > 800){
     rectMode(CORNER);
     textAlign(LEFT);
     textFont(titleFont[3]);
     fill(200);
     textLeading(height*0.03f);
     fill(0xFFEBEAF3);
     text(title3_1,width/6,height/6);
     fill(0xFF5BAEAD);
     text("Directing",width/6,height/6);

     fill(0xFFEBEAF3);
     text(title3_2,width/6,2*height/6);
     fill(0xFF5BAEAD);
     text("Coding",width/6,2*height/6);

     fill(0xFFEBEAF3);
     text(title3_3,width/6,3*height/6);
     fill(0xFF5BAEAD);
     text("MusicComposing",width/6,3*height/6);
  
     textFont(titleFont[3]);
     fill(0xFFEBEAF3);
     text(title3_4,width/6,4*height/6,0.8f*width,0.15f*height);
     }
  else if (sceneDuration < 800 && sceneDuration > 400){
    textFont(titleFont[3]);
    textAlign(LEFT);
    fill(0xFF5BAEAD);
    text("[Conceived and developed by]::",width/6,2*height/6);
    fill(0xFFEBEAF3);
    text(title5,width/6,3*height/6);
    fill(241,228,126);
    text("</espam>",width/6,3*height/6);
    pushMatrix();
    imageMode(CENTER);
    translate(width*3/4,height/2);
    scale(0.3f);
    image(logo1,0,0);
    popMatrix();   
    }
  else if (sceneDuration < 400 && sceneDuration > 200){
    pushMatrix();
    imageMode(CENTER);
    translate(width/2,height/2);
    scale(0.1f);
    image(logo2,0,0);
    popMatrix();   
    }
  else if (sceneDuration < 200 && sceneDuration > 0){
     pushMatrix();
     translate(width/2,height/2);
     textAlign(CENTER);
     textFont(titleFont[0]);
     fill(colorArray[2]);
     text("{copyleft 2021}",0,10);
     popMatrix();
     pushMatrix();
     textAlign(LEFT);
     translate(3*width/10,9*height/10);
     textFont(titleFont[3]);
     fill(0xFFEBEAF3);
     text("//Download other artifacts at: linktr.ee/ritmo2021",0,0);
     fill(colorArray[5]);
     text("//Download other artifacts at:",0,0);
     popMatrix();  
     exit();
    }
  frameCompleted();
  }    
}//class ends
class Scene{//Scene abstract superclass. Every scene inherits from this
   int sceneDuration;
   

 public boolean isEndScene(){//Checks whether a scene is completed (when number of frames left is zero)
  if(sceneDuration>0) return false;
  else return true;}

 public void frameCompleted(){//When a frame is completed, the number of remaining frames in decreased by one
  sceneDuration=sceneDuration-1;
  }

 public void finishScene(){ //Finish the scene when called by setting remaing frames to zero
   sceneDuration=0; 
}

 public void setDuration(int _sceneDuration){ //Scene durarion setter.
  sceneDuration=_sceneDuration; 
}

 public void display(){} //Abstract method. Every scene implements how the scene is displayed
}
/*
Just for fun
*/


  public void settings() { fullScreen(P3D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "ritmo2021_Android" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
